#lang rosette

(require "../dense-fjmodels.rkt")
(require "../densefjapi.rkt")
(require "../straightline.rkt")
(require "../benchmarks/incdecbutton.rkt")

(current-bitwidth #f)

(define (straightline-graph inc dec)
  (define r1 inc)
  (define r2 dec)
  (define r3 (constantE 1 r1))
  (define r4 (constantE -1 r2))
  (define r5 (mergeE r3 r4))
  (define r6 (collectE 0 + r5))
  (define r7 (startsWith 0 r6))
  r7)

(displayln "inc/dec button benchmark")

(define v-binding (verify (assert (same inc-dec-button-graph
                                        straightline-graph
                                        s-inc s-dec))))
(if (unsat? v-binding)
    (displayln "verified example implementation and straightline program are equivalent")
    (displayln "can't verify that straightline program matches example implementation"))

(define holes (for/list ([i (range 5)])
                          (get-insn-holes)))
(define-symbolic* retval-idx integer?)
  ;; need to generate this
(define (sketch-graph1 input1 input2)
  (define r1 input1)
  (define r2 input2)
  r1)
(define (sketch-graph2 input1 input2)
  (define r1 input1)
  (define r2 input2)
  r2)
(define (sketch-graph3 input1 input2)
  (define r1 input1)
  (define r2 input2)
  (define r3 (call-stream-insn (list-ref holes 0) (list r1 r2)))
  r3)
(define (sketch-graph4 input1 input2)
  (define r1 input1)
  (define r2 input2)
  (define r3 (call-stream-insn (list-ref holes 0) (list r1 r2)))
  (define r4 (call-stream-insn (list-ref holes 1) (list r1 r2 r3)))
  r4)
(define (sketch-graph5 input1 input2)
  (define r1 input1)
  (define r2 input2)
  (define r3 (call-stream-insn (list-ref holes 0) (list r1 r2)))
  (define r4 (call-stream-insn (list-ref holes 1) (list r1 r2 r3)))
  (define r5 (call-stream-insn (list-ref holes 2) (list r1 r2 r3 r4)))
  r5)
(define (sketch-graph6 input1 input2)
  (define r1 input1)
  (define r2 input2)
  (define r3 (call-stream-insn (list-ref holes 0) (list r1 r2)))
  (define r4 (call-stream-insn (list-ref holes 1) (list r1 r2 r3)))
  (define r5 (call-stream-insn (list-ref holes 2) (list r1 r2 r3 r4)))
  (define r6 (call-stream-insn (list-ref holes 3) (list r1 r2 r3 r4 r5)))
  r6)
(define (sketch-graph7 input1 input2)
  (define r1 input1)
  (define r2 input2)
  (define r3 (call-stream-insn (list-ref holes 0) (list r1 r2)))
  (define r4 (call-stream-insn (list-ref holes 1) (list r1 r2 r3)))
  (define r5 (call-stream-insn (list-ref holes 2) (list r1 r2 r3 r4)))
  (define r6 (call-stream-insn (list-ref holes 3) (list r1 r2 r3 r4 r5)))
  (define r7 (call-stream-insn (list-ref holes 4) (list r1 r2 r3 r4 r5 r6)))
  r7)
(define-symbolic* timer-int integer?)
(define (timer-sketch-graph input1 input2)
  (define t0 (timerE timer-int input1))
  (define r1 input1)
  (define r2 input2)
  (define r3 (call-stream-insn (list-ref holes 0) (list t0 r1 r2)))
  (define r4 (call-stream-insn (list-ref holes 1) (list t0 r1 r2 r3)))
  (define r5 (call-stream-insn (list-ref holes 2) (list t0 r1 r2 r3 r4)))
  (define r6 (call-stream-insn (list-ref holes 3) (list t0 r1 r2 r3 r4 r5)))
  (define r7 (call-stream-insn (list-ref holes 4) (list t0 r1 r2 r3 r4 r5 r6)))
  (list-ref (list t0 r1 r2 r3 r4 r5 r6 r7) retval-idx))
(define (sketch-graph input1 input2)
  (define r1 input1)
  (define r2 input2)
  (define r3 (call-stateless-stream-insn (list-ref holes 0) (list r1 r2)))
  (define r4 (call-stateless-stream-insn (list-ref holes 1) (list r1 r2 r3)))
  (define r5 (call-stateless-stream-insn (list-ref holes 2) (list r1 r2 r3 r4)))
  (define r6 (call-stream-insn (list-ref holes 3) (list r1 r2 r3 r4 r5)))
  (define r7 (call-stream-insn (list-ref holes 4) (list r1 r2 r3 r4 r5 r6)))
  (list-ref (list r1 r2 r3 r4 r5 r6 r7) retval-idx))

;; note: adding these assertions makes synthesis ~10s slower (z3 time)
#;(assert (and (>= (stream-insn-arg-index1 (list-ref holes 0)) 0)
             (< (stream-insn-arg-index1 (list-ref holes 0)) 2)
             (>= (stream-insn-arg-index1 (list-ref holes 1)) 0)
             (< (stream-insn-arg-index1 (list-ref holes 1)) 3)
             (>= (stream-insn-arg-index1 (list-ref holes 2)) 0)
             (< (stream-insn-arg-index1 (list-ref holes 2)) 4)
             (>= (stream-insn-arg-index1 (list-ref holes 3)) 0)
             (< (stream-insn-arg-index1 (list-ref holes 3)) 5)
             (>= (stream-insn-arg-index1 (list-ref holes 4)) 0)
             (< (stream-insn-arg-index1 (list-ref holes 4)) 6)))

(define binding (time (synthesize #:forall (harvest s-inc s-dec)
                                  #:guarantee (assert (same inc-dec-button-graph
                                                            sketch-graph
                                                            s-inc s-dec)))))
(if (unsat? binding)
    (displayln "synthesis model is unsat")
    (displayln "synthesis model is sat"));(print-from-holes (evaluate holes binding) (evaluate retval-idx binding) 2))

;(define (input-output-synthesis depth input-count)
;(define depth 5)
;(define input-count 2)
;  (define holes-structure (for/list ([i (range depth)])
;                            (get-insn-holes)))
;  (define-symbolic* return-index integer?)
;  (define (sketch-graph input1 input2)
;    (define r1 input1)
;    (define r2 input2)
;    (define r3 (single-insn (list-ref holes-structure 0) (list r1 r2)))
;    (define r4 (single-insn (list-ref holes-structure 1) (list r1 r2 r3)))
;    (define r5 (single-insn (list-ref holes-structure 2) (list r1 r2 r3 r4)))
;    (define r6 (single-insn (list-ref holes-structure 3) (list r1 r2 r3 r4 r5)))
;    (define r7 (single-insn (list-ref holes-structure 4) (list r1 r2 r3 r4 r5 r6)))
;    (list-ref (list r1 r2 r3 r4 r5 r6 r7) return-index))
;  (define holes-structure2 (for/list ([i (range depth)])
;                             (get-insn-holes)))
;  (define-symbolic* return-index2 integer?)
;  (define (sketch-graph2 input1 input2)
;    (define r1 input1)
 ;   (define r2 input2)
 ;   (define r3 (single-insn (list-ref holes-structure2 0) (list r1 r2)))
 ;   (define r4 (single-insn (list-ref holes-structure2 1) (list r1 r2 r3)))
 ;   (define r5 (single-insn (list-ref holes-structure2 2) (list r1 r2 r3 r4)))
 ;   (define r6 (single-insn (list-ref holes-structure2 3) (list r1 r2 r3 r4 r5)))
 ;   (define r7 (single-insn (list-ref holes-structure2 4) (list r1 r2 r3 r4 r5 r6)))
  ;  (list-ref (list r1 r2 r3 r4 r5 r6 r7) return-index2))
  ;(define input-inc-button (list 'no-evt 'no-evt 'no-evt))
  ;(define input-dec-button (list 'no-evt 'no-evt 'no-evt))
  ;(define output (inc-dec-button-graph input-inc-button input-dec-button))
  ;(define distinguishing-input-inc (new-event-stream (Î» () 'click) stream-length))
  ;(define distinguishing-input-dec (new-event-stream (Î» () 'click) stream-length))
;(for ([i (range stream-length)])
 ; (assert (or (eq? 'no-evt (list-ref distinguishing-input-inc i))
  ;            (eq? 'no-evt (list-ref distinguishing-input-dec i)))))
  ;(define binding (time (synthesize #:forall '()
   ;                                 #:guarantee (assert (and (eq? (sketch-graph input-inc-button input-dec-button) output)
    ;                                                         (eq? (sketch-graph2 input-inc-button input-dec-button) output)
     ;                                                        (not (same sketch-graph sketch-graph2 distinguishing-input-inc
      ;                                                                    distinguishing-input-dec))))
       ;                                          )))
;(if (unsat? binding)
;    (displayln "unsat")
;    (begin
;      (print-from-holes holes-structure return-index binding depth input-count)
;      (print-from-holes holes-structure2 return-index2 binding depth input-count)
;      (displayln (format "distinguishing input inc button: ~a" (evaluate distinguishing-input-inc binding)))
;      (displayln (format "distinguishing input dec button: ~a" (evaluate distinguishing-input-dec binding)))))
;  ;binding)
