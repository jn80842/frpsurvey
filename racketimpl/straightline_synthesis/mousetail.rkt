#lang rosette

(require "../dense-fjmodels.rkt")
(require "../densefjapi.rkt")
(require "../uf-straightline.rkt")
(require "../benchmarks/mousetail.rkt")

(current-bitwidth #f)

(define (straightline-mousetail-y-graph y-stream)
  (define r1 y-stream)
  (define r2 (delayE 3 r1))
  r2)

(define (straightline-mousetail-x-graph x-stream)
  (define r1 x-stream)
  (define r2 (delayE 3 r1))
  (define r3 (mapE (Î» (e) (+ e x-offset)) r2))
  r3)

(assert (mousetail-assumptions s-mouse-x s-mouse-y))

(displayln "mousetail benchmark")

(define v-binding-x (verify (assert (same mousetail-x-graph straightline-mousetail-x-graph s-mouse-x))))
(if (unsat? v-binding-x)
    (displayln "verified example mouse-x implementation and straightline mouse-x program are equivalent")
    (displayln "can't verify straightline mouse-x program is equiv to example implementation"))
(define v-binding-y (verify (assert (same mousetail-y-graph straightline-mousetail-y-graph s-mouse-y))))
(if (unsat? v-binding-y)
    (displayln "verified example mouse-y implementation and straightline mouse-y program are equivalent")
    (displayln "can't verify straightline mouse-y program is equiv to example implementation"))

(define x-holes (for/list ([i (range 2)])
                  (get-insn-holes)))
(define-symbolic* x-retval-idx integer?)
(define y-holes (for/list ([i (range 1)])
                  (get-insn-holes)))
(define-symbolic* y-retval-idx integer?)
(define x-state-mask (list->vector (list #t #f)))
(define y-state-mask (make-vector 1 #t))
(define binding (time (synthesize #:forall (harvest s-mouse-x s-mouse-y)
                                  #:guarantee (assert (and (same straightline-mousetail-x-graph
                                                                (recursive-sketch x-holes x-retval-idx x-state-mask)
                                                                s-mouse-x)
                                                           (same straightline-mousetail-y-graph
                                                                 (recursive-sketch y-holes y-retval-idx y-state-mask)
                                                                 s-mouse-y))))))
(if (unsat? binding)
    (displayln "unsat")
    ;(displayln "sat"))
    (begin (print-from-holes (evaluate x-holes binding) x-state-mask
                             (evaluate x-retval-idx binding) 1)
           (print-from-holes (evaluate y-holes binding) y-state-mask
                             (evaluate y-retval-idx binding) 1)))

(define (x-spec program)
  (equal? (program '(1 no-evt no-evt no-evt)) '(no-evt no-evt no-evt 6)))
(define (y-spec program)
  (equal? (program '(1 no-evt no-evt no-evt)) '(no-evt no-evt no-evt 1)))

(define spec-binding (time (synthesize #:forall '()
                                       #:guarantee (assert (and (x-spec (recursive-sketch x-holes x-retval-idx x-state-mask))
                                                                (y-spec (recursive-sketch y-holes y-retval-idx y-state-mask)))))))
(if (unsat? spec-binding)
    (displayln "no program found that matches spec")
    (begin (print-from-holes (evaluate x-holes spec-binding) x-state-mask
                             (evaluate x-retval-idx spec-binding) 1)
           (print-from-holes (evaluate y-holes spec-binding) y-state-mask
                             (evaluate y-retval-idx spec-binding) 1)))

#;(define x-holes-prime (for/list ([i (range 2)])
                  (get-insn-holes)))
;(define-symbolic* x-retval-idx-prime integer?)
#;(define y-holes-prime (for/list ([i (range 2)])
                  (get-insn-holes)))
;(define-symbolic* y-retval-idx-prime integer?)
#;(define (x-sketch-graph-prime input)
  (define r1 input)
  (define r2 (call-stream-insn (list-ref x-holes-prime 0) (list r1)))
  (define r3 (call-stream-insn (list-ref x-holes-prime 1) (list r1 r2)))
  (list-ref (list r1 r2 r3) x-retval-idx-prime))
#;(define (y-sketch-graph-prime input)
  (define r1 input)
  (define r2 (call-stream-insn (list-ref y-holes-prime 0) (list r1)))
  (define r3 (call-stream-insn (list-ref y-holes-prime 1) (list r1 r2)))
  (list-ref (list r1 r2 r3) y-retval-idx-prime))

#;(define distinguishing-binding (time (synthesize #:forall '()
                                                 #:guarantee (assert (and (x-spec x-sketch-graph)
                                                                          (x-spec x-sketch-graph-prime)
                                                                          (y-spec y-sketch-graph)
                                                                          (y-spec y-sketch-graph-prime)
                                                                          (or (not (equal? (x-sketch-graph s-mouse-x) (x-sketch-graph-prime s-mouse-x)))
                                                                              (not (equal? (y-sketch-graph s-mouse-y) (y-sketch-graph-prime s-mouse-y)))))))))
#;(if (unsat? distinguishing-binding)
    (displayln "could not find programs with distinguishing input")
    (begin (displayln "first mouse-x solution")
           (print-from-holes (evaluate x-holes distinguishing-binding)
                             (evaluate x-retval-idx distinguishing-binding) 1)
           (displayln "second mouse-x solution")
           (print-from-holes (evaluate x-holes-prime distinguishing-binding)
                             (evaluate x-retval-idx-prime distinguishing-binding) 1)
           (displayln "distinguishing mouse-x input")
           (displayln (evaluate s-mouse-x distinguishing-binding))
           (displayln "first mouse-y solution")
           (print-from-holes (evaluate y-holes distinguishing-binding)
                             (evaluate y-retval-idx distinguishing-binding) 1)
           (displayln "second mouse-y solution")
           (print-from-holes (evaluate y-holes-prime distinguishing-binding)
                             (evaluate y-retval-idx-prime distinguishing-binding) 1)
           (displayln "distinguishing mouse-y input")
           (displayln (evaluate s-mouse-y distinguishing-binding))))